
### Basic Problem List with Descriptions

1.  **Arrays and Strings**: Solve a problem involving array manipulation.
2.  **Binary Search**: Implement and solve a problem using binary search.
3.  **Linked Lists**: Reverse a linked list.
4.  **Dynamic Programming**: Solve a classic DP problem (e.g., Fibonacci sequence).
5.  **Trees**: Implement a binary tree and perform in-order traversal.
6.  **Hash Maps**: Solve a problem using a hash map (e.g., finding duplicates).
7.  **Graphs**: Implement a basic graph and perform BFS.
8.  **Recursion**: Solve a problem using recursion (e.g., permutations of a string).
9.  **Sorting Algorithms**: Implement quicksort.
10.  **Stacks and Queues**: Solve a problem using a stack (e.g., valid parentheses).
11.  **Heaps**: Implement a min-heap and solve a related problem.
12.  **Bit Manipulation**: Solve a problem involving bitwise operations.
13.  **Trees**: Find the lowest common ancestor in a binary tree.
14.  **Sliding Window**: Solve a problem using the sliding window technique.
15.  **Greedy Algorithms**: Solve a classic greedy problem (e.g., coin change).
16.  **Graphs**: Implement DFS on a graph.
17.  **Linked Lists**: Detect and remove a cycle in a linked list.
18.  **Dynamic Programming**: Solve a problem involving DP (e.g., longest common subsequence).
19.  **Hash Maps**: Implement a simple LRU cache.
20.  **Arrays and Strings**: Solve a problem involving string manipulation (e.g., anagram check).
21.  **Trees**: Implement a balanced binary search tree (AVL tree).
22.  **Recursion**: Solve a complex recursion problem (e.g., N-Queens).
23.  **Graphs**: Solve a shortest path problem (e.g., Dijkstra's algorithm).
24.  **Bit Manipulation**: Solve a problem involving bitwise manipulation (e.g., counting bits).
25.  **Sorting Algorithms**: Implement mergesort.
26.  **Stacks and Queues**: Implement a queue using two stacks.
27.  **Heaps**: Solve a median-finding problem using heaps.
28.  **Sliding Window**: Solve a maximum subarray sum problem.
